{"meta":{"title":"Xiaoniu's Blog","subtitle":"This blog is rarely maintained :(","description":null,"author":"Xiaoniu Song","url":"http://yoursite.com","root":"/"},"pages":[{"title":"About Me","date":"2019-07-30T06:33:34.000Z","updated":"2019-07-30T12:01:52.462Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Xiaoniu SongPh.D CandidateInstitute of Parallel and Distributed SystemsShanghai Jiao Tong UniversityResume"}],"posts":[{"title":"k近邻","slug":"2017-07-04-k-NN","date":"2019-07-30T11:33:37.257Z","updated":"2019-07-30T11:33:37.257Z","comments":true,"path":"2019/07/30/2017-07-04-k-NN/","link":"","permalink":"http://yoursite.com/2019/07/30/2017-07-04-k-NN/","excerpt":"","text":"k近邻法针对分类问题 没有显式的学习过程，其训练集即为其“模型” k近邻算法输入：训练数据集 T={(x_1,y_1),(x_2,y_2),...,(x_N,y_N)}其中，$x_i\\in\\mathcal{X}\\subseteq R^n$为实例的特征向量，$y_i \\in \\mathcal{Y} ={c_1,c_2,…,c_K}$为实例类别，$i=1,2,…N$; ​输出：实例$x$所属类$y$ 根据给定的距离度量，在训练集$T$中找出与$x$距离最近的$k$个点($k$近邻)，包含这$k$个点的$x$的邻域记作$N_k(x)$ 在$N_k(x)$中根据分类决策规则，(最典型的 多数表决)决定$x$的类别$y$：y=arg \\max \\limits_{c_j} \\sum \\limits_{x_i\\in N_k(x)} I(y_i=c_j),i=1,2,...,N; j=1,2,...K其中，$I$为指示函数，I=\\begin {cases}1,y_i=c_j \\\\ 0,y_i\\ne c_j \\end{cases}{}没有类似感知机中的参数的学习过程，直接将输入的训练数据作为模型 k近邻模型距离度量不同的距离度量算出的距离不同，其确定的最近邻点也不同 距离度量：对于一个度量空间，其距离度量可以有多种一般为欧式距离 d(x_i,x_j)=\\sqrt{\\sum \\limits_{l=1} \\limits^{n} |x_i^{(l)}-x_j^{(l)}|^2}更一般的，$L_p$距离 L_p(x_i,x_j)=\\sqrt[p]{\\sum \\limits_{l=1} \\limits^{n} |x_i^{(l)}-x_j^{(l)}|^p}, p\\geqslant1 不同p值下与零点距离为1的点集 邻域：包含该点的开球，一般以该点为中心 k值的选择若$k$较小，即相当于用一个较小的邻域中的训练实例进行预测 近似误差将减小，只有与实例较为接近的训练实例才会对预测结果起作用 估计误差将增大，预测结果对近邻的实例点更敏感。若附近的点恰好为噪声，预测便出错 $k$值减小将使整体模型变得复杂，易过拟合 $k=1$，成为最近邻算法 若$k$较大，即相当于用一个较大的邻域中的训练实例进行预测 估计误差减小，近似误差增大。较远的数据点也将影响预测 整体模型变得简单 $k$过大($N$)，模型过于简单，忽略训练集中大量有用信息，不可取 如何确定$k$值？交叉验证 如果样本充足，比较简单的方法是将数据集分为三部分：训练集，验证集，测试集用训练集训练多个不同复杂度的模型，用验证集选择最佳模型，用测试集进行评估大部分应用中数据不充足，交叉验证即分为训练集与测试集，重复使用数据，反复训练 简单交叉验证分为训练集与测试集，用训练集训练出多个模型，用测试集评价，选出误差最小的模型 S折交叉验证将数据切分为S个等大子集，用S-1个子集数据进行训练，剩下一个作为测试集。选取训练出的模型中误差最小的那一个 S=N时，称为留一交叉验证 分类决策规则往往是多数表决若记分类的损失函数为0-1损失函数 L(Y,f(X))=\\begin{cases}1,Y\\ne f(X) \\\\0,Y=f(X) \\end{cases}那么将有：多数表决等价于经验风险最小化（即误分类率最小化） 误分类率：\\frac{1}{k}\\sum\\limits_{x_i\\in N_k(x)}I(y_i\\neq c_j)=1-\\frac{1}{k}\\sum\\limits_{x_i\\in N_k(x)}I(y_i= c_j) k近邻法的实现：kd树最简单的$k$ 近邻法的实现：线性扫描，遍历整个训练集计算距离 $kd$ 树：对$k$维空间中的实例点进行储存，以进行快速检索的数据结构 二叉树，构造时不断用超平面切分空间，构成一系列超矩形区域。树的每一个结点对应一个超矩形区域 这里的$k$是指$k$维空间，与$k$近邻法的$k$意义不同 算法：构造kd树​ 输入：$k$维空间数据集T=\\{x_1,x_2,...,x_N\\} 其中x_i=(x_i^{(1)},x_i^{(2)},...,x_i^{(k)})^T,i=1,2,...,N ​ 输出：$kd$树 ​ （1）开始：根节点：包含T的$k$维空间的超矩形区域 ​ x^{(1)}为坐标轴，以T中所有实例的x^{(1)}坐标的中位数作为切分点，将根节点的超矩形区域分为两个子区域。 ​ 在这个根结点中，保存所有落在该切分超平面上的实例点。 ​ （2）重复：对每个深度为j的结点，记l=j(modk)+1，选择x^{(l)}为切分坐标轴，以该结点的超矩形区域中所有实例的x^{(l)}坐标的中位数作为切分点，将该节点的超矩形区域分为两个子区域。 ​ 在这个结点中，保存所有落在该切分超平面上的实例点。 ​ （3）当两个子区域中均无实例存在时停止。$kd$树构造完毕 简单的例子T=\\{(2,3)^T,(5,4)^T,(9,6)^T,(4,7)^T,(8,1)^T,(7,2)^T\\} Tree 搜索kd树$kd$树的每个结点的内容 一个超平面，以及其上面的实例点，被保存于该结点中 一个超矩形区域 最近邻搜索算法​ 输入：$kd$树，目标点$x$ ​ 输出：$x$的最近邻 ​ （1）找出包含目标点的叶结点：从根结点开始，递归地向下访问：如果$x$当前维的坐标小于切分点的坐标，进入左子结点，否则进入右子结点。直到访问到叶结点为止。 ​ （2）记该叶结点为“当前最近点” ​ （3）从当前最近点开始，递归地往根结点回退，在每个结点进行如下操作： ​ （a）若当前结点中所保存的实例点比当前最近点的距离短，以该实例点为当前最近点 ​ （b）检查当前结点的父结点的另一子结点对应的超矩形区域，是否与当前最短距离为半径、$x$为球心形成的超球体相交。 ​ 若相交，则该子结点对应的超矩形区域中的实例点可能存在比当前最近点更近的点，移至这一子结点，以其为根结点，递归地进行最近邻搜索（step（1）） ​ 若不相交，向根结点方向回退 ​ （4）回退到根结点时搜索结束。最后的当前最近点即为$x$的最近邻点 示例 kd tree 如何改进以寻找k近邻？将当前最近点改为一个长为$k$的链表，初始化为无限远点。 每次比较，以链表末尾（当前$k$近邻中最远点）作为当前最近点来比较。每次更新链表时插入新结点，移除末结点","categories":[],"tags":[]},{"title":"OrayVPN failed to ping each other when connecting to eduroam","slug":"2018-12-14-OrayVPN","date":"2018-12-13T16:00:00.000Z","updated":"2019-07-30T11:35:04.566Z","comments":true,"path":"2018/12/14/2018-12-14-OrayVPN/","link":"","permalink":"http://yoursite.com/2018/12/14/2018-12-14-OrayVPN/","excerpt":"","text":"A strange thing happened this morning. I failed to connect my desktop with my laptop connecting to eduroam, but succeeded when connecting to my cellphone’s hotspot. By runing route print in CMD, the interface of that entry is found to be set to WLAN: However, when connecting to hotspot, the interface is set to the virtual adapter of VPN. The solution is manully delete and create a new entry with correct interface.12route delete &lt;entryIP&gt;route add &lt;entryIP&gt; mask &lt;MASK&gt; &lt;GATEWAY&gt; &lt;INTERFACE&gt; metric 56 if &lt;INTERFACE&gt; The interface id is shown in route printOr, I set the adapter’s mask to cover all the devices in my VPN, so just delete that entry would be fine.","categories":[],"tags":[]},{"title":"Add Bash-here to right-click context","slug":"2018-01-23-add-bash-here","date":"2018-01-22T16:00:00.000Z","updated":"2019-07-30T11:35:04.564Z","comments":true,"path":"2018/01/23/2018-01-23-add-bash-here/","link":"","permalink":"http://yoursite.com/2018/01/23/2018-01-23-add-bash-here/","excerpt":"","text":"Method to add Bash here in your right-click context. Basic IdeaIn cmd/powershell, bash command will get into wsl bash and set current directory. In regedit, add items to HKEY_CLASSES_ROOT\\Directory\\Background\\shell to add thing in your right-click context at a directory’s blank background. Further more, HKEY_CLASSES_ROOT\\Folder\\shell or HKEY_CLASSES_ROOT\\Directory\\shell is for right-click on a folder. Add Bash here in right click context at dir’s backgroundIf the bash.exe is in your system PATH, these codes would work. Otherwise, you have to specify the path of bash.exe. 1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\WSL]@=&quot;Bash here&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\WSL\\command]@=&quot;bash&quot; Save texts above to a .reg file and run it. Another interesting thing, when I install Everything, I forgot to add it to my right click context. So in Powershell, I ran &amp; &#39;C:\\Program Files\\Everything\\Everything.exe&#39; --help and find out -p parameter can pass the current folder to Everything and open an instance. Thus: 123456789Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Everything]@=&quot;Everything here&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Everything\\command]@=&quot;C:\\\\Program Files\\\\Everything\\\\Everything.exe -p .&quot;","categories":[],"tags":[]},{"title":"MapReduce summary","slug":"2018-01-22-MapReduce","date":"2018-01-21T16:00:00.000Z","updated":"2019-07-30T11:35:04.564Z","comments":true,"path":"2018/01/22/2018-01-22-MapReduce/","link":"","permalink":"http://yoursite.com/2018/01/22/2018-01-22-MapReduce/","excerpt":"","text":"摘要，IntroMapReduce: 一种编程模型，产生、处理大数据集 并行、分布式的实现细节对程序员透明 Map:对输入中的每一个Logical “record”，应用Map操作，计算出一组中间KVPairs Reduce: 对中间KVpairs中key相同的pair进行适当的合并 [TOC] 编程模型map由用户编写，对输入的kvp产生一组中间kvp。MR库将key相同的中间value打包，传给reduce(通过迭代器Iterator传递，从而允许不连续存放) reduce由用户编写，将value合并为可能更小的value集合(通常只产生0或1个输出)。 example: 统计单词出现次数 12345678910111213&gt; map(String key, String value):&gt; # key: document name&gt; # value: content&gt; for w in value:&gt; EmitIntermediate(w, \"1\")&gt; reduce(Stringkey, Iterator values):&gt; # key: a word&gt; # values: list of counts&gt; result = 0&gt; for v in values:&gt; result += ParseInt(v)&gt; Emit(AsString(result))&gt; 中间key与value的类型与输出相同，但与输入不同 Our(?) C++实现传递值均为字符串，由用户解释 分布式Grep、URL访问频数统计、转置Web连接图、统计每个主机的高频关键词，单词索引，分布式排序 实现可有多种不同实现(针对不同设备) 机器错误经常出现 主节点(Master)、工作节点(Worker) MapReduce库将输入分块，Cluster中多台机器运行一个副本 副本中主结点分配Map与Reduce任务给其余结点 Map的结点读取输入块内容，获取KVP后传给map函数，中间KVP缓存于内存 内存中的中间KVP被周期划分，存入磁盘，磁盘位置传给主结点再传给reduce结点 reduce结点获得位置后调用RPC读取中间KVP，按key排序(可能外部排序) reduce结点将同key的values传给reduce函数，结果写到最终输出文件的末尾 reduce完成后主结点唤醒用户，mapreduce返回 容错主结点周期ping所有结点 工作结点错误：已完成的map需重新进行，正在进行的map与reduce需重新进行(reduce结果存在Global File System) reduce结点都将收到重执行的通知，从而从新结点重新读取 主结点错误：simple：定期保存恢复点。current：终止mapreduce，用户检查、重启 map与reduce输出的提交为原子的 输出被写入私有temp文件，reduce有一个这样的文件，map有R个 完成时： map完成时结点发给主节点临时文件名字。主结点收到已完成结点的消息，忽略；否则记录文件名 reduce完成时，原子更名将临时输出改为最终输出。若因为出错、备用机制使同一个reduce任务在多个机器执行，底层FS提供的原子更名操作保证FS只含其中一个结果 确定性语义 不确定的语义 局部GFS，3备份，map就近分配 粒度MR比机器数大很多，动态平衡，加速失败恢复。上限。R由用户指定。M使输入分为16~64MB 备用任务接近完成时，将剩余任务调度给其他机器同时执行 技巧 划分函数：根据key用不同方式划分给reduce任务 顺序：中间kvp增序 合并：中间kvp发出前先又map机器执行局部合并 输入输出类型：text例子 边界效应：？ 信号处理程序，catch出错，通过UDP发给主节点，下一次跳过该记录 本地调试 http server，查看状态 counter 结论成功原因： 首先，该模型即使是对于没有并行和分布式系统经验的程序员也是很易于使用的，因为它隐藏了并行化、容错机制、局部性优化、以及负载平衡的细节。 其次，很多种类的问题都很容易表示成MapReduce计算。例如，MapReduce被用于为Google的网络搜索服务的数据产生、排序、数据挖掘、机器学习、以及许多其它系统。 第三，我们已经开发了一个MapReduce的实现，可以扩展到包含上千台机器的大型集群。该实现可以高效使用这些机器的资源，因此适合于Google遇到的很多大型计算问题。 经验： 首先，约束这个编程模型令并行和分布式计算，以及令这些计算可容错，变得简单了。 其次，网络带宽是一种稀缺资源。我们系统中的很多优化都因此针对减少通过网络发送的数据总量：局部性优化允许我们从本地磁盘读，同时将中间文件写入本地磁盘也节省了网络带宽。 第三，备用执行可以用于减小缓慢的机器的影响，及应对机器失败和数据丢失。","categories":[],"tags":[]},{"title":"Configure ur own github page","slug":"2018-01-15-configure-your-githubio","date":"2018-01-15T07:50:41.000Z","updated":"2019-07-30T11:35:04.564Z","comments":true,"path":"2018/01/15/2018-01-15-configure-your-githubio/","link":"","permalink":"http://yoursite.com/2018/01/15/2018-01-15-configure-your-githubio/","excerpt":"","text":"LayoutsLayouts decides in what kind of format, each of your page will be presented. In folder _layouts you can make your own layouts (the default layout is page). Create default.html inside _layouts and add these into it: undefined PostsCreate a _post directory. All your posts should be placed inside here and named as YYYY-MM-DD-title-of-post.md(or markdown, textile, see Jekyll posts). The post file should looks like this: 1234567---layout: singletitle: \"first post\"date: 2018-01-15 15:50:41 +8000---post content The header tells Jekyll that this file should be processd by Jekyll, and gives this file some attributes(title &amp; date), and you can use them for example the inside default.html. The layout indicates which layout this post uses. By default, you can use post for posts and page for htmls as layout without creating your own layout file. To view your post, browse http://username.github.io/YYYY/MM/DD/name-of-yout-post. **Note**: if you want Jekyll to ignore texts like `{{ this }}`, there are two ways: * replace `{{ this }}` with {{ \"{{ this \" }}}} * replace `{% this %}` with {{ \"{% this \" }}%} * place target texts inside `{% raw %} ... {{\" {% endraw \" }}%}` {% endraw %} IndexWhen you browse https://username.github.io, you actually browse index.html at the repository’s root. Here is a good index.html example that lists all your posts with title and date: {% raw %} undefined {% endraw %} See Jekyll/variables for more detail about the variables used here. More customizeBy editing the _config.yml file,","categories":[],"tags":[]},{"title":"研究生抢课脚本","slug":"2018-01-12-yjsqk","date":"2018-01-12T09:45:41.000Z","updated":"2019-07-30T11:35:04.567Z","comments":true,"path":"2018/01/12/2018-01-12-yjsqk/","link":"","permalink":"http://yoursite.com/2018/01/12/2018-01-12-yjsqk/","excerpt":"","text":"抢课脚本本文档脚本内容适用于USTC研究生选课系统 如下文所说，你需要指定自己想选的课程号，并可以修改你想要的每次查询时间间隔 方法1 浏览器console此方法需要每次打开选课主页手动粘贴运行脚本 Chrome下，F12快捷键打开开发者工具 点击上方Console进入控制台(如上图红圈) 确认当前在top域(如上图红圈)，在console中粘贴如下代码，并按回车： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//在这里添加你想要的课程号们，不限制个数var ids = [\"CH6520501\", \"CH6620401\", \"CH2522301\"];//在这里修改每多久查询一次，单位毫秒。不要过于频繁以免被服务器封禁。原为5000。var times = 5000;var got = [];for (var i = 0; i &lt; ids.length; i++) &#123; got.push(false);&#125;var inter = setInterval(function() &#123; var log_string = \"\"; var table = frames[\"mainFrame\"].frames[\"I2\"].frames[\"xkpFrame\"].document.children[0].children[1].children[0].children[0].children[2].children[0]; for (var i = 0; i &lt; ids.length; i++) &#123; var line = get_line_with_id(table, ids[i]); var people = line.children[8]; if (got[i] === false) &#123; if (people.childNodes[0].data != (people.childNodes[3].innerText + \"/\")) &#123; frames[\"mainFrame\"].frames[\"I2\"].frames[\"xkpFrame\"].xk(ids[i]); got[i] = true; alert(\"class\" + toString(i) + \" get!\"); &#125; else &#123; log_string = log_string + line.children[3].children[0].innerText + \" : \" + people.childNodes[0].data + people.childNodes[3].innerText + \"\\n\"; //console.log(line.children[3].children[0].innerText + \" : \" + people.childNodes[0].data + people.childNodes[3].innerText); &#125; &#125; &#125; for (var i = 0; i &lt; got.length; i++) &#123; if (got[i] === false) &#123; console.log(log_string); frames[\"mainFrame\"].frames[\"I2\"].frames[\"xkpFrame\"].cxdxkc(); return; &#125; &#125; clearInterval(inter); alert(\"all get!\"); return;&#125;, times);function get_line_with_id(table, id) &#123; for (i = 1; i &lt; table.rows.length; i++) &#123; if (table.rows[i].children[2].innerText == id) &#123; return table.rows[i]; &#125; &#125; return null;&#125; 每查询一次，脚本将在console中输出当次查询的人数结果： 若你不想有这样的输出，将上图中Default levels中的Info取消勾选 当你想结束查询时，请刷新选课界面 方法2 使用插件Tampermonkey此方法可以自动在选课页面打开时进行刷课，无需人工干预 在Chrome扩展商店中搜索Tampermonkey并安装，安装完成后在Chrome地址栏右侧将出现该扩展的图标： 点击该图标，并选择添加新脚本，进入下图界面 你可以： 将上文中的代码粘贴到图中// Your code here...的位置，并用选课网页地址替换掉图中match之后的http开头的内容 (推荐)将编辑区中所有内容清除，替换为下文内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// ==UserScript==// @name yanjiusheng// @namespace http://tampermonkey.net/// @version 1.1// @description multiple classes supported// @author Jeffery// @match http://mis.teach.ustc.edu.cn/gradLoginSuc.do// @grant none// ==/UserScript==(function() &#123; 'use strict'; //在这里添加你想要的课程号们，不限制个数 var ids = [\"CH6520501\", \"CH6620401\", \"CH2522301\"]; //在这里修改每多久查询一次，单位毫秒。不要过于频繁以免被服务器封禁。原为5000。 var times = 5000; var got = []; for (var i = 0; i &lt; ids.length; i++) &#123; got.push(false); &#125; var inter = setInterval(function() &#123; var log_string = \"\"; var table = frames[\"mainFrame\"].frames[\"I2\"].frames[\"xkpFrame\"].document.children[0].children[1].children[0].children[0].children[2].children[0]; for (var i = 0; i &lt; ids.length; i++) &#123; var line = get_line_with_id(table, ids[i]); var people = line.children[8]; if (got[i] === false) &#123; if (people.childNodes[0].data != (people.childNodes[3].innerText + \"/\")) &#123; frames[\"mainFrame\"].frames[\"I2\"].frames[\"xkpFrame\"].xk(ids[i]); got[i] = true; alert(\"class\" + toString(i) + \" get!\"); &#125; else &#123; log_string = log_string + line.children[3].children[0].innerText + \" : \" + people.childNodes[0].data + people.childNodes[3].innerText + \"\\n\"; //console.log(line.children[3].children[0].innerText + \" : \" + people.childNodes[0].data + people.childNodes[3].innerText); &#125; &#125; &#125; for (var i = 0; i &lt; got.length; i++) &#123; if (got[i] === false) &#123; console.log(log_string); frames[\"mainFrame\"].frames[\"I2\"].frames[\"xkpFrame\"].cxdxkc(); return; &#125; &#125; clearInterval(inter); alert(\"all get!\"); return; &#125;, times); function get_line_with_id(table, id) &#123; for (i = 1; i &lt; table.rows.length; i++) &#123; if (table.rows[i].children[2].innerText == id) &#123; return table.rows[i]; &#125; &#125; return null; &#125; // Your code here...&#125;)(); 点击保存按钮 启用脚本方法： 打开选课标签页 点击Tampermonkey扩展按钮，将出现当前脚本的开关 打开该开关，并刷新选课页面(刷新后才开启生效)，若观察到隔指定时间(5000ms)页面自动查询，或在Chrome console看到课程人数的输出并且前缀数字增加，则为开启成功： Tip: 你可以选择开课单位，以减少每次查找的流量、时间开销 关闭脚本方法：同启用脚本的方法，仅将打开开关改为关闭开关。别忘了刷新页面！ Note：如果你有旧的抢课脚本，请在开启脚本的小弹窗关闭它并保持关闭，或在Tampermonkey管理面板永久删除它：","categories":[],"tags":[]}]}